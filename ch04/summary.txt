리스트(list)는 순열이라고도 불리며, 순서를 가지고 일렬로 나열한 요소들의 모음으로 정의한다.
리스트는 집합과 유사하지만, 순서 또는 위치를 가진다는 점에서 구별된다.

(1) 리스트 ADT
-. 객체 : n개의 element형으로 구성된 순서있는 컬렉션
-. 연산 : 
	a. add_last(list, item) ::= 맨끝에 요소를 추가한다.
	b. add_first(list, item) ::= 맨앞에 요소를 추가한다.
	c. add(list, pos, item) ::= pos 위치에 요소를 추가한다.
	d. delete(list, pos) ::= pos 위치의 요소를 제거한다.
	e. clear(list) ::= 리스트의 모든 요소를 제거한다.
	f. get_length(list) ::= 리스트의 길이를 구한다.
	g. is_empty(list) ::= 리스트가 비어있는지를 검사한다.
	h. get_entry(list, pos) ::= pos 위치의 요소를 반환한다.
	i. replace(list, pos, item) ::= pos 위치의 요소를 item으로 바꾼다.

(2) 리스트 구현
리스트를 구현하는 방법에는 크게 2가지가 있다.
첫 번째는 배열을 이용하여 구현하는 방법이다. 이 경우, 삽입/삭제 시 오버헤드가 발생한다.
두 번째는 연결 리스트를 이용하여 구현하는 방법이다. 이 경우, 순회/탐색 시 오버헤드가 발생한다.
	a. 배열을 이용한 리스트 ADT
		typedef struct s_listArrayType
		{
			element	list[MAX_LIST_SIZE];
			size_t	size;
		}
	b. 연결 리스트를 이용한 리스트 ADT
		typdef struct __s_node
		{
			void		*content;
			struct __s_node	*prev;
			struct __s_node	*next;
		}	__t_node;
		typedef struct s_listLinkedType
		{
			__t_node	*head;
			size_t		size;
		}	t_listLinkedType;

(3) 연결 리스트
배열은 메모리 안에 순차적으로 공간이 할당되어 있는 순차적 표현이다.
그에 반해, 연결 리스트(linked list)는 물리적으로 흩어져 있는 자료들이 서로 연결되어 있는 형태인 연결된 표현이다.
이 연결된 표현은 데이터 필드와 링크 필드로 구성되어 있고, 링크 필드가 요소들을 연결하는 역할을 한다. C에서는 포인터로 링크 필드를 구현한다.

연결 리스트는 노드들의 집합이며, 이들은 데이터를 저장하고 있고 서로 연결되어 있다.
연결 리스트에서는 첫 번째 노드를 알아야만이 전체의 노드에 접근할 수 있다.
따라서, 연결 리스트마다 첫 번째 노드를 가리키고 있는 변수가 필요한데 이 것을 헤드 포인터(head pointer)라고 한다.
그리고, 연결 리스트의 마지막 노드의 링크 필드는 NULL로 설정되는데 이는 더 이상 연결된 노드가 없다는 것을 의미한다.

연결 리스트에는 다음과 같은 3가지의 연결 리스트가 있다.
-. 단순 연결 리스트(singly linked list) ::= 각 노드마다 링크 필드가 1개씩이고, 단방향으로 연결된다.
-. 이중 연결 리스트(doubly linked list) ::= 각 노드마다 링크 필드가 2개씩이고, 양방향으로 연결된다. 노드 삭제 구현의 편의성 측면에서 이점이 있다.
-. 원형 연결 리스트(circular linked list) ::= 단순 연결 리스트와 같으나, 마지막 노드의 링크값이 첫 번째 노드를 가리킨다. 메모리 재할당 구현 측면에서 이점이 있다.

실제 응용에서는 헤드 노드(head node)라는 특별한 노드를 추가하는 경우가 많다.
헤드 노드는 데이터를 가지고 있지 않는 특별한 노드를 추가하는 것이다.
헤드 노드가 존재하게 되면 삽입/삭제 알고리즘 구현이 간편해진다.

(4) 리스트 ADT 연산 vs 연결 리스트 연산
리스트의 항목들을 순차적으로 방문하면서 어떤 작업을 해야 되는 경우, 리스트 ADT 연산보다 연결 리스트가 제공하는 포인터를 이용한 연산이 더 효율적이다.
따라서, 이런 경우에는 리스트 ADT보다는 직접 연결 리스트가 제공하는 함수, 또는 포인터를 이용한 작업이 효율성 측면에서 더 좋다.
객체 지향 언어들에서는 이런 경우를 위하여 반복자(Iterator)라는 개념으로 순차적으로 객체를 효율적으로 방문하면서 작업할 수 있도록 각종 연산을 제공해주기도 한다.
