(1) 프렌드 클래스, 프렌드 멤버 함수
비멤버 함수들이 클래스가 가질 수 있는 프렌드의 유일한 종류는 아니다.
비멤버 함수뿐만 아니라, 다른 클래스나 다른 클래스의 특정 멤버 함수들을 프렌드로 지정할 수 있다.

프렌드 클래스는 다른 클래스가 어떤 클래스의 프렌드가 되도록 지정할 떄 사용할 수 있으며, 예를 들어 아래와 같이 선언할 수 있다.
ex)	class Tv {
	public:
		friend class Remote;					// 프렌드 지정은 public, protected, private 부분 어디에나 둘 수 있다.
	};

	class Remote {
	};

프렌드 멤버 함수는 다른 클래스의 특정 멤버 함수들만 어떤 클래스의 프렌드가 되도록 지정할 때 사용할 수 있다.
프렌드 멤버 함수는 예를 들어 아래와 같이 지정할 수 있으며, 이 경우 선언 순서에 주의해야 한다.
이 때, 전방 선언(forward declaration)을 사용하여 올바르게 동작하게 할 수 있다.
ex)	class Tv;
	class Remote {
	public:
		void	setChannel(Tv& t, int c);			// Remote 클래스 내부에서 Tv 클래스를 사용하기 때문에, Tv 클래스를 전방 선언해야 한다.
	};

	class Tv {
	public:
		friend void	Remote::setChannel(Tv& t, int c);	// Remote 클래스 선언이 Tv 클래스 선언보다 앞에 있어야 한다.
	private:
		int	_channel;
	};

	void	Remote::setChannel(Tv& t, int c)
	{
		t._channel = c;
	}

(2) 중첩 클래스
중첩 클래스(nested class)는 어떤 클래스의 내부에 선언된 클래스를 의미한다.
중첩 클래스를 사용하는 일반적인 이유는, 어떤 클래스의 구현을 지원하고, 이름 충돌을 막는 것이다.
중첩 클래스를 사용한다는 것은 클래스 사용 범위를 가지는 데이터형을 제공하는 의미를 가지기 때문에, 클래스의 데이터 멤버로 포함되어지는 컨테인먼트와는 개념적으로 다르다.
ex)	class Queue {
	private:
		class Node {
		public:
			explicit Node();
		};
	};

	Queue::Node::Node()
	{}

클래스 템플릿 내부에 또 다른 클래스 템플릿을 작성할 수 있다.
예를 들어 아래와 같이 작성한 경우, 클래스 템플릿의 멤버 함수를 작성할 때 템플릿 표시를 중첩시켜야 할 때도 있다.
ex)	template <typename T>
	class Beta {
	public:
		explicit Beta(T t, int i);
	private:
		template <typename V>
		class Hold {
		public:
			explicit Hold(V val = 0);
		private:
			V	_val;
		};

		Hold<T>		_q;
		Hold<int>	_n;
	};

	template <typename T>
	Beta<T>::Beta(T t, int i)
		: _q(t), _n(i)
	{}

	template <typename T>
	template <typename V>
	Beta<T>::Hold<V>::Hold(V val)
		: _val(val)
	{}

	Beta<double>	guy(3.5, 3);

(3) 예외 처리
C++의 예외 처리는 프로그램을 먹통으로 만드는 특별한 상황에 대처하는 메커니즘을 제공한다.
예외가 발생하면, 현재 실행 중인 함수가 종료되고, 예외 데이터형과 일치하는 catch 블록으로 제어가 넘어간다.
예외가 발생하면, 스택 되감기(Stack unwinding)라 부르는 과정이 일어나면서 catch 블록을 찾아가는데, 이 때 중요한 특징은 자동 수명 객체들에 대하여 함수 리턴과 마찬가지로 소멸자들이 호출된다는 것이다.

catch 블록들은 try 블록 바로 뒤에 온다.
예외를 포착하기 위해서는, 직접 또는 간접으로 예외를 발생시키는 함수 호출이 try 블록 안에 있어야 한다.
그러면 프로그램은 그 catch 블록 안에 있는 코드를 실행한다. 그 코드는 문제를 해결하려 시도할 수도 있고, 프로그램을 종료시킬 수도 있다.
ex)	double	x, y, z;

	while (std::cin >> x >> y)
	{
		try
		{
			if (x == -y)					// throw 키워드는 예외의 발생을 나타낸다.
				throw "";				// throw 키워드의 뒤에는 그 예외의 특징을 나타내는, 문자열이나 객체와 같은 하나의 값이 뒤따른다.
			z = 2.0 * x * y / (x + y);			// 예외가 발생하면 try 블록과 throw 구문 사이에 개입된 모든 함수 호출들이 스택에 올려 놓은 자동 수명 객체들의 소멸자들이 호출된다.
		};
		catch (const char *s)					// catch 키워드는 예외의 포착을 나타낸다.
		{							// catch 키워드의 뒤에는 그 예외의 데이터형 선언이 (소괄호에) 나타난다.
			std::cerr << s << std::endl;			// catch 키워드는 프로그램의 실행이 점프하는 지점을 나타내는 레이블의 역할을 한다.
			continue;
		}
		std::cout << x << ", " << y << "" << z << std::endl;
	}

그 클래스에 고유한 문제들이 감지될 때 발생할 수 있는, 내포된 예외 클래스들을 사용하여 클래스를 설계할 수 있다.
ex)	

포착되지 않는 예외(일치하는 catch 블록이 없는 예외)는, 기본적으로 프로그램을 종료시킨다.
기대하지 않는 예외(예외 지정에 없는 예외)도, 기본적으로 프로그램을 종료시킨다.
ex)	

함수는, 그 함수에서 발생할 수 있는 예외들을 인식하는 예외 지정을 포함할 수 있다.
ex)	

(4) RTTI
RTTI(Run Time Type Information; 실행 시간 데이터형 정보)는 객체들의 데이터형을 식별하는 메커니즘이다.
RTTI 기능은 프로그램이 실행 시간에 객체의 데이터형을 인지하도록 허용한다.

(5) 데이터형 변환 연산자
C++의 데이터형 변환 연산자들은 데이터형 변환의 안전성을 개선한다.

-------------

C의 전통적인 예외처리 기법
-. 프로그램 종료 (abort, exit)
-. 예외 발생 여부를 전역 변수에 저장
-. 예외 발생 여부를 호출하는 함수들이 리턴 (이 경우, 출력 값을 전달받기 위하여 별도의 포인터 매개변수를 활용)
