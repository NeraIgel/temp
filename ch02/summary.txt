순환(recursion)은 어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법이다.

(1) 순환 호출의 내부적인 구현
하나의 함수가 자기 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일하다.
복귀주소가 시스템 스택에 저장되고, 호출되는 함수를 위한 파라미터(parameter)와 지역 변수를 스택으로부터 할당받는다.
이러한 함수를 위한 시스템 스택에서의 공간을 활성 레코드(activation record)라 한다. 이러한 준비가 끝나면 호출된 함수의 시작 위치로 점프하여 수행을 시작한다.

만약, 호출된 함수가 자기 자신이라면 자기 자신의 시작 위치로 점프하게 된다.
호출된 함수가 끝나게 되면 시스템 스택에서 복귀 주소를 추출하여 호출한 함수로 되돌아간다.

(2) 순환 알고리즘의 구조
순환 알고리즘은 자기 자신을 순환적으로 호출하는 부분과 순환 호출을 멈추는 부분으로 구성되어 있다.
만약, 순환 호출을 멈추는 부분이 없다면 시스템 스택을 모두 사용할 때까지 순환적으로 호출되다가 에러를 내면서 멈출 것이다.
따라서, 반드시 순환 호출에는 순환 호출을 멈추는 문장이 포함되어야 하며 입력값이 종료 조건으로 올바르게 수렴하는지를 검증해야 한다.

(3) 순환 <-> 반복
프로그래밍 언어에서 되풀이하는 방법에는 반복(iteration)과 순환(recursion)의 2가지가 있다.
기본적으로 반복과 순환은 그 표현 능력이 같으며 많은 경우, 특히 순환 호출이 끝에서 이루어지는 꼬리 순환 알고리즘의 경우, 반복 알고리즘으로 바꿀 수 있다.

일반적으로, 순환은 함수 호출을 하게 되므로 반복에 비해 수행속도 측면에서 떨어진다.
그러나, 어떤 문제에서는 순환이 반복에 비해 알고리즘을 훨씬 명확하고 간결하게 나타낼 수 있기도 하고, 순환이 더 빠른 예제도 존재한다.

순환은 알고리즘의 정의가 순환적으로 되어 있는 경우에 유리한 방법이다.
예를 들어, 팩토리얼 함수 계산, 피보나치 수열, 이항계수 계산, 각종 이진 트리 알고리즘, 이진 탐색, 하노이 탑 문제들은 순환 알고리즘을 쓰는 것이 자연스럽다.

(4) 꼬리 순환
꼬리 순환(tail recursion)은 순환 호출이 순환 함수의 맨 끝에서 이루어지는 형태이다.
꼬리 순환의 경우, 알고리즘을 쉽게 반복적인 형태로 변환이 가능하다.
-. return (n * factorial(n - 1));

머리 순환(head recursion)은 순환 호출이 순환 함수의 맨 앞에서 이루어지는 형태이다.
머리 순환의 경우나 여러 군데에서 자기 자신을 호출하는 경우, 쉽게 반복적인 코드르 변경할 수 없다.
-. return (factorial(n - 1) * n);

만약, 동일한 알고리즘을 꼬리 순환과 머리 순환 양쪽으로 모두 표현할 수 있다면, 당연히 꼬리 순환으로 작성하여야 한다.

(5) 순환 알고리즘 구현 예제
	a. 팩토리얼
		int	factorial(int n)
		{
			if (n <= 1)	return (1);
			else		return (n * factorial(n - 1));
		}
	b. 피보나치
		int	fib(int n)
		{
			if (n == 0)	return (0);
			if (n == 1)	return (1);
			return (fib(n - 1) + fib(n - 2));
		}
	c. 거듭제곱
		double	power(double x, int n)
		{
			if 	(n == 0)	return (1);
			else if ((n % 2) == 0)	return (power(x * x, n / 2));
			else			return (x * power(x * x, (n - 1) / 2));
		}
	d. 하노이탑
		void	hanoi_tower(int n, char from, char tmp, char to)
		{
			if (n == 1)
				printf("원판 1을 %c에서 %c으로 옮긴다.\n", from, to);
			else
			{
				hanoi_tower(n - 1, from, to, tmp);
				printf("원판 %d을 %c에서 %c으로 옮긴다.\n", from, to);
				hanoi_tower(n - 1, tmp, from, to);
			}
		}

		int	main(void)
		{
			hanoi_tower(4, 'A', 'B', 'C');
			return (0);
		}
